/* Code generated by IfcQuery EXPRESS generator, www.ifcquery.com */

#include <sstream>
#include <limits>
#include <map>
#include "ifcpp/reader/ReaderUtil.h"
#include "ifcpp/writer/WriterUtil.h"
#include "ifcpp/model/BasicTypes.h"
#include "ifcpp/model/BuildingException.h"
#include "ifcpp/IFC4X3/include/IfcSIPrefix.h"

// TYPE IfcSIPrefix = ENUMERATION OF	(ATTO	,CENTI	,DECA	,DECI	,EXA	,FEMTO	,GIGA	,HECTO	,KILO	,MEGA	,MICRO	,MILLI	,NANO	,PETA	,PICO	,TERA);
void IFC4X3::IfcSIPrefix::getStepParameter( std::stringstream& stream, bool is_select_type, size_t precision ) const
{
	if( is_select_type ) { stream << "IFCSIPREFIX("; }
	switch( m_enum )
	{
		case ENUM_ATTO:	stream << ".ATTO."; break;
		case ENUM_CENTI:	stream << ".CENTI."; break;
		case ENUM_DECA:	stream << ".DECA."; break;
		case ENUM_DECI:	stream << ".DECI."; break;
		case ENUM_EXA:	stream << ".EXA."; break;
		case ENUM_FEMTO:	stream << ".FEMTO."; break;
		case ENUM_GIGA:	stream << ".GIGA."; break;
		case ENUM_HECTO:	stream << ".HECTO."; break;
		case ENUM_KILO:	stream << ".KILO."; break;
		case ENUM_MEGA:	stream << ".MEGA."; break;
		case ENUM_MICRO:	stream << ".MICRO."; break;
		case ENUM_MILLI:	stream << ".MILLI."; break;
		case ENUM_NANO:	stream << ".NANO."; break;
		case ENUM_PETA:	stream << ".PETA."; break;
		case ENUM_PICO:	stream << ".PICO."; break;
		case ENUM_TERA:	stream << ".TERA."; break;
	}
	if( is_select_type ) { stream << ")"; }
}
shared_ptr<IFC4X3::IfcSIPrefix> IFC4X3::IfcSIPrefix::createObjectFromSTEP( const std::string& arg, const BuildingModelMapType<int,shared_ptr<BuildingEntity> >& map, std::stringstream& errorStream, std::unordered_set<int>& entityIdNotFound )
{
	if( arg.size() == 0 ) { return shared_ptr<IfcSIPrefix>(); }
	if( arg.compare( "$" ) == 0 ) { return shared_ptr<IfcSIPrefix>(); }
	if( arg.compare( "*" ) == 0 ) { return shared_ptr<IfcSIPrefix>(); }
	shared_ptr<IfcSIPrefix> type_object( new IfcSIPrefix() );
	if( std_iequal( arg, ".ATTO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_ATTO;
	}
	else if( std_iequal( arg, ".CENTI." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_CENTI;
	}
	else if( std_iequal( arg, ".DECA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_DECA;
	}
	else if( std_iequal( arg, ".DECI." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_DECI;
	}
	else if( std_iequal( arg, ".EXA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_EXA;
	}
	else if( std_iequal( arg, ".FEMTO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_FEMTO;
	}
	else if( std_iequal( arg, ".GIGA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_GIGA;
	}
	else if( std_iequal( arg, ".HECTO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_HECTO;
	}
	else if( std_iequal( arg, ".KILO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_KILO;
	}
	else if( std_iequal( arg, ".MEGA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_MEGA;
	}
	else if( std_iequal( arg, ".MICRO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_MICRO;
	}
	else if( std_iequal( arg, ".MILLI." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_MILLI;
	}
	else if( std_iequal( arg, ".NANO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_NANO;
	}
	else if( std_iequal( arg, ".PETA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_PETA;
	}
	else if( std_iequal( arg, ".PICO." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_PICO;
	}
	else if( std_iequal( arg, ".TERA." ) )
	{
		type_object->m_enum = IfcSIPrefix::ENUM_TERA;
	}
	return type_object;
}
